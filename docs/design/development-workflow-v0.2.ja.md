# Kiwumil 開発ワークフロー v0.2.0

## 概要

このドキュメントは、Kiwumil v0.2.0の開発ワークフローを定義します。コアドメイン「**レイアウトセマンティクスのドメイン翻訳エンジン**」を中心に構成されています。ワークフローはフェーズベースで、各フェーズに特化したエージェントが責任を持ちます。

## ワークフローの原則

1. **セマンティクス第一**: APIの設計や実装の前に、常にレイアウトセマンティクスの定義から始める
2. **翻訳駆動**: セマンティックから制約へのマッピングの正確性に焦点を当てる
3. **段階的**: 小さく検証可能な単位で作業する
4. **エージェント特化**: 各フェーズに適切なエージェントを使用する
5. **ドキュメント追跡**: 全体を通じて設計ドキュメントを維持する

## 開発フェーズ

### フェーズ1: 要件とセマンティクス設計

**目標**: サポートするレイアウトセマンティクスと、それらが制約にどのようにマッピングされるかを定義する

**主要エージェント**: `semantics-designer`

**入力**:
- ユーザー要件や機能リクエスト
- レイアウト問題の説明
- 他のレイアウトシステムからの例

**活動**:
1. **レイアウト意図の分析**
   - 人間レベルのレイアウト概念を特定
   - どのセマンティックカテゴリーに属するかを決定 (配置、間隔、グループ化、階層、バランス)
   - 典型的なユースケースを文書化

2. **セマンティック語彙の定義**
   - セマンティック操作に名前を付ける
   - パラメータとオプションを指定
   - 他のセマンティクスとの組み合わせルールを定義

3. **翻訳ルールの設計**
   - セマンティックを制約方程式にマッピング
   - 制約の強度を指定
   - エッジケースと競合解決を文書化
   - 実際の制約出力を含む例を提供

4. **セマンティックパターンの文書化**
   - `docs/design/semantics/`にセマンティック仕様を記述
   - 例、翻訳ルール、組み合わせパターンを含める
   - 有用であれば視覚的な図を追加

**出力**:
- セマンティック仕様ドキュメント
- 例を含む翻訳ルール
- 検証フェーズ用のテストシナリオ

**統合ポイント**: セマンティック仕様をフェーズ2 (API設計) に引き渡し

---

### フェーズ2: API設計

**目標**: レイアウトセマンティクスを表現するための型安全で流暢なAPIを設計する

**主要エージェント**: `dsl-architect`

**入力**:
- フェーズ1からのセマンティック仕様
- `src/dsl/`の既存のAPIパターン
- TypeScript型システムの要件

**活動**:
1. **APIサーフェスの設計**
   - セマンティックのための流暢なビルダーメソッドを作成
   - メソッドチェーンパターンを設計
   - パラメータ型と戻り値型を指定

2. **型安全性の設計**
   - TypeScriptインターフェースと型を定義
   - 可能な限りコンパイル時制約を作成
   - 無効な組み合わせのエラー型を設計

3. **プラグインシステム統合**
   - 名前空間の配置を決定
   - 必要に応じてプラグイン登録を設計
   - 既存のAPIとの組み合わせ可能性を確保

4. **IntelliSense最適化**
   - API発見可能性のためのJSDocコメントを記述
   - オートコンプリートのための型シグネチャを設計
   - 一般的なパターンのための型エイリアスを作成

5. **APIドキュメント**
   - `docs/api/`にAPI使用法を文書化
   - コード例を提供
   - 型制約を説明

**出力**:
- APIインターフェース定義 (TypeScript型)
- API使用法ドキュメント
- 実装用のコード例

**統合ポイント**: API仕様をフェーズ3 (実装) に引き渡し

---

### フェーズ3: 実装

**目標**: 制約翻訳ロジックとDSLコンポーネントを実装する

**主要エージェント**: `implementation-planner` (汎用)

**入力**:
- フェーズ1からのセマンティック仕様
- フェーズ2からのAPI設計
- 既存のコードベース構造

**活動**:
1. **翻訳ロジックの実装**
   - `src/translator/` (または適切な場所) にトランスレーター関数を作成
   - セマンティック入力からCassowary制約方程式を生成
   - 制約の強度割り当てを処理
   - 組み合わせロジックを実装

2. **DSLビルダーの実装**
   - `src/dsl/`に流暢なビルダークラスを作成
   - メソッドチェーンを実装
   - 翻訳ロジックに接続
   - パラメータ検証を処理

3. **シンボルモデル統合**
   - 必要に応じてシンボルクラスを更新
   - 変数バインディングを管理
   - シンボル間の関係を追跡

4. **エラー処理**
   - 検証ロジックを実装
   - 有益なエラーメッセージを作成
   - エッジケースを適切に処理

5. **コードドキュメント**
   - 複雑なロジックにインラインコメントを追加
   - 翻訳アルゴリズムを文書化
   - 設計決定を説明

**出力**:
- 適切なディレクトリの実装コード
- 翻訳関数のユニットテスト
- 既存のコードベースとの統合

**統合ポイント**: 実装をフェーズ4 (検証) に引き渡し

---

### フェーズ4: 検証

**目標**: 制約翻訳の正確性と一貫性を検証する

**主要エージェント**: `constraint-verification-engineer`

**入力**:
- フェーズ3からの実装
- フェーズ1からのテストシナリオ
- 翻訳ルール仕様

**活動**:
1. **翻訳テストの作成**
   - 個別の翻訳ルールのユニットテスト
   - 制約方程式の正確性を検証
   - 制約の強度割り当てをテスト
   - 組み合わせ動作を検証

2. **プロパティベーステスト**
   - セマンティック不変条件を定義
   - ランダムな有効入力を生成
   - すべての入力でプロパティが保持されることを検証
   - 境界条件をテスト

3. **ソルバー検証**
   - 生成された制約でCassowaryソルバーを実行
   - 解がセマンティック意図と一致することを検証
   - 過剰制約シナリオをテスト
   - 不足制約の処理を検証

4. **リグレッションテスト**
   - リグレッションテストスイートを作成
   - 既知のエッジケースを文書化
   - テストフィクスチャを維持
   - テスト実行を自動化

5. **統合テスト**
   - セマンティックの組み合わせをテスト
   - 競合解決を検証
   - 複雑なレイアウトシナリオをテスト
   - エンドツーエンドのワークフローを検証

**出力**:
- `test/`の包括的なテストスイート
- テストドキュメント
- 検証レポート
- 問題が見つかった場合のフェーズ3へのバグレポート

**統合ポイント**: 検証が合格するまでフェーズ3と反復し、その後フェーズ5へ

---

### フェーズ5: ドキュメントとリリース

**目標**: 機能を文書化し、リリースの準備をする

**主要エージェント**: `requirements-librarian`

**入力**:
- フェーズ1からのセマンティック仕様
- フェーズ2からのAPIドキュメント
- フェーズ3と4からの実装とテスト

**活動**:
1. **ユーザードキュメント**
   - `docs/guide/`にユーザーガイドを記述
   - チュートリアル例を作成
   - 一般的なパターンを文書化
   - セマンティック概念を説明

2. **APIリファレンス**
   - コードからAPIドキュメントを生成
   - セマンティックカテゴリー別に整理
   - 使用例を追加
   - 関連概念へのリンク

3. **設計ドキュメント**
   - アーキテクチャドキュメントを更新
   - 設計決定を文書化
   - 翻訳ルールカタログを維持
   - ドメインモデル図を更新

4. **リリースノート**
   - 新機能を文書化
   - 破壊的変更をリスト化
   - 必要に応じて移行ガイドを提供
   - 貢献者を謝辞

5. **翻訳の同期**
   - 日本語ドキュメントが英語と一致することを確認
   - 新しいコンテンツを翻訳
   - 技術的正確性をレビュー
   - 一貫性を維持

**出力**:
- 完全なドキュメントセット
- リリースノート
- 移行ガイド (該当する場合)
- 更新されたREADMEと例

**統合ポイント**: 機能が完成し、リリースの準備が整った

---

## エージェント調整

### 引き継ぎプロトコル

フェーズ間で引き継ぐ際:

1. **完了基準の文書化**: 何が達成されたかを明確に記述
2. **コンテキストの提供**: 関連するドキュメントとディスカッションへのリンク
3. **成果物のリスト**: 作成されたすべてのドキュメント、コード、テストを列挙
4. **次のステップの指定**: 次のエージェントが何をすべきかを明示的に記述
5. **ブロッカーのフラグ**: 未解決の問題や依存関係を注記

### 引き継ぎ例 (フェーズ1 → フェーズ2)

```markdown
## DSL Architectへの引き継ぎ (フェーズ2)

**完了**: "均等分布"レイアウトのセマンティック仕様

**成果物**:
- `docs/design/semantics/distribute-evenly.md`
- 制約方程式を含む翻訳ルール
- 5つのテストシナリオ

**セマンティック概要**:
- 名前: `distribute(elements).horizontally().evenly()`
- カテゴリー: バランス/分布
- 制約パターン: 要素間の等間隔

**DSL Architectへの次のステップ**:
1. distribute操作の流暢なAPIを設計
2. 要素コレクションのTypeScript型を作成
3. 方向と戦略のメソッドチェーンを設計
4. `docs/api/distribute.md`にAPIを文書化

**ブロッカー**: なし
```

### 反復プロトコル

検証が失敗した場合や問題が発見された場合:

1. **問題の文書化**: 再現手順を含む明確な問題説明を作成
2. **根本原因の分類**: セマンティック設計、API設計、実装バグのいずれか?
3. **適切なフェーズに戻る**: 
   - セマンティック問題 → フェーズ1
   - API設計問題 → フェーズ2
   - 実装バグ → フェーズ3
4. **ドキュメントの更新**: 学んだ教訓を反映
5. **再検証**: 修正後、フェーズ4に戻る

## ワークフロー図

### 順次フロー

```
┌─────────────────────────────────────────────┐
│  フェーズ1: 要件とセマンティクス設計         │
│  エージェント: semantics-designer           │
│  出力: セマンティック仕様                    │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│  フェーズ2: API設計                          │
│  エージェント: dsl-architect                │
│  出力: API仕様                               │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│  フェーズ3: 実装                             │
│  エージェント: implementation-planner       │
│  出力: コード + ユニットテスト               │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│  フェーズ4: 検証                             │
│  エージェント: constraint-verification-engineer │
│  出力: テストスイート + 検証レポート         │
└─────────────────────────────────────────────┘
                    ↓
              [合格/不合格?]
                    ↓
            ┌───────┴───────┐
            ↓               ↓
         [合格]          [不合格]
            ↓               ↓
            ↓          [フェーズ1/2/3
            ↓           に戻る]
            ↓               ↓
            └───────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│  フェーズ5: ドキュメントとリリース           │
│  エージェント: requirements-librarian       │
│  出力: 完全なドキュメント                    │
└─────────────────────────────────────────────┘
```

### 並列活動

いくつかの活動は並列で行うことができます:

- **フェーズ2 (API設計)** は、フェーズ1がセマンティックの洗練を続けている間に、複数のAPIオプションを探索できる
- **フェーズ4 (検証)** は、フェーズ3が実装を完了する前にテスト足場を書くことができる
- **フェーズ5 (ドキュメント)** は、フェーズ4がテストを実行している間にユーザーガイドを開始できる

## ベストプラクティス

### Semantics Designerのため
- 制約メカニズムではなく、人間レベルのレイアウト概念に焦点を当てる
- 制約方程式の前後を含む具体的な例を提供する
- 組み合わせルールを明示的に文書化する
- エッジケースと競合を早期に考慮する

### DSL Architectのため
- 発見可能性とIntelliSenseを優先する
- セマンティックエラーを防ぐためにTypeScript型を使用する
- APIを流暢でチェーン可能に保つ
- 一貫性のために既存のDSLパターンに従う

### Implementation Plannerのため
- 指定された翻訳ルールに正確に従う
- セマンティック前提条件の検証を追加する
- 翻訳ロジックをDSLレイヤーから分離する
- 複雑な制約生成ロジックにコメントを付ける

### Constraint Verification Engineerのため
- ソルバーの正確性ではなく、翻訳の正確性をテストする
- セマンティック不変条件にプロパティベーステストを使用する
- 見つかったすべてのバグのリグレッションテストを作成する
- テストの根拠と期待される動作を文書化する

### Requirements Librarianのため
- 言語間でドキュメントを同期させる
- セマンティック仕様から一貫した用語を使用する
- 実行可能なコード例を提供する
- 関連する概念間をリンクする

## 言語ポリシー

- **コード**: 英語 (コメント、変数名、ドキュメント文字列)
- **ドキュメント**: 英語 (主要)、日本語 (同期翻訳)
- **エージェント通信**: リクエストの言語で応答
- **Gitコミット**: 英語
- **課題追跡**: 英語または日本語、必要に応じて翻訳

## 品質ゲート

次のフェーズに進む前に、以下を確認:

### フェーズ1後:
- [ ] セマンティック概念が明確に定義されている
- [ ] 翻訳ルールが例とともに文書化されている
- [ ] 組み合わせ動作が指定されている
- [ ] テストシナリオが概説されている

### フェーズ2後:
- [ ] APIがTypeScriptのベストプラクティスに従っている
- [ ] 型安全性制約が整っている
- [ ] APIドキュメントが完成している
- [ ] コード例が提供されている

### フェーズ3後:
- [ ] 翻訳ロジックが仕様と一致している
- [ ] コードがリントと型チェックに合格している
- [ ] ユニットテストが書かれている
- [ ] 統合ポイントが検証されている

### フェーズ4後:
- [ ] すべてのテストが合格している
- [ ] 翻訳の正確性が検証されている
- [ ] エッジケースが処理されている
- [ ] リグレッションテストが整っている

### フェーズ5後:
- [ ] ユーザードキュメントが完成している
- [ ] APIリファレンスが生成されている
- [ ] 日本語翻訳が同期されている
- [ ] リリースノートが準備されている

## ツール

- **ソース管理**: Gitとフィーチャーブランチ
- **言語**: TypeScript
- **テスト**: Jest (または設定されたテストフレームワーク)
- **リント**: TypeScript付きESLint
- **ドキュメント**: Markdown + JSDoc
- **ビルド**: TypeScriptコンパイラ + バンドラー

## バージョン管理戦略

- **フィーチャーブランチ**: `feat/<semantic-name>` 新しいセマンティクス用
- **ドキュメントブランチ**: `docs/<topic>` ドキュメント更新用
- **メインブランチ**: `main` 安定リリース用
- **開発ブランチ**: `develop` または `feat/v0.2.0` 統合用

## 成功指標

- **翻訳の正確性**: 100%のセマンティック翻訳が正しい制約を生成
- **テストカバレッジ**: 翻訳ロジックの>90%カバレッジ
- **API一貫性**: すべてのセマンティクスが共通のAPIパターンに従う
- **ドキュメント品質**: すべてのセマンティクスに仕様 + APIドキュメント + 例がある
- **型安全性**: セマンティックエラーが実行時ではなくコンパイル時に捕捉される

## 例: "中央揃え"セマンティクスの完全なワークフロー

### フェーズ1: セマンティクス設計
**エージェント**: `semantics-designer`

**出力**: `docs/design/semantics/align-center.md`
```markdown
# 中央揃えセマンティック

## 意図
参照フレーム内で要素を水平または垂直に中央配置する。

## 語彙
- `align(element).center.to(reference)`
- `align(element).horizontally.center()`
- `align(element).vertically.center()`

## 翻訳ルール
- 水平: `element.x + element.width/2 == reference.x + reference.width/2`
- 垂直: `element.y + element.height/2 == reference.y + reference.height/2`
- 強度: デフォルトで`required`

## 組み合わせ
- 間隔制約と組み合わせ可能
- 包含制約と互換性あり
- 固定位置制約と競合する可能性 (強度を使用して解決)
```

### フェーズ2: API設計
**エージェント**: `dsl-architect`

**出力**: TypeScriptインターフェース + ドキュメント
```typescript
interface AlignmentBuilder {
  center: {
    to(reference: LayoutSymbol): Constraint;
    horizontally(): Constraint;
    vertically(): Constraint;
  };
}
```

### フェーズ3: 実装
**エージェント**: `implementation-planner`

**出力**: 実装コード
```typescript
class AlignmentBuilder {
  center = {
    to: (reference: LayoutSymbol) => {
      return new Constraint(
        this.element.centerX,
        Operator.Eq,
        reference.centerX,
        Strength.required
      );
    }
  };
}
```

### フェーズ4: 検証
**エージェント**: `constraint-verification-engineer`

**出力**: テストスイート
```typescript
describe('align().center.to()', () => {
  it('正しい水平中央配置制約を生成する', () => {
    const constraint = align(box).center.to(container);
    expect(constraint.expression).toBe('box.x + box.width/2 == container.x + container.width/2');
    expect(constraint.strength).toBe(Strength.required);
  });
});
```

### フェーズ5: ドキュメント
**エージェント**: `requirements-librarian`

**出力**: ユーザーガイド + APIリファレンス

## まとめ

このワークフローは以下を保証します:
- 明確な関心事の分離 (セマンティクス、API、実装、検証、ドキュメント)
- 各タスクに適切なエージェント
- フェーズ間の品質ゲート
- フィードバックループを通じた反復的改善
- 全体を通じた包括的なドキュメント

このワークフローに従うことで、Kiwumilは正確で組み合わせ可能なセマンティックから制約への翻訳を持つ**ドメイン翻訳エンジン**としての焦点を維持します。
